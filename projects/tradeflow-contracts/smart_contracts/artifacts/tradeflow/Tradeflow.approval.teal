#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 2 3
    bytecblock "st" "ib" "ia" "nextInvoiceId" 0x151f7c75 "is" "ir" "inv" "im"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/tradeflow/contract.algo.ts:24
    // nextInvoiceId = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_3 // "nextInvoiceId"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0xf2a64e98 0x7cd8b57f 0xbb0c6942 0x429ccc4d 0x99932e33 0xeab8be70 0x414faa1c // method "createInvoice(address,uint64,uint64,uint64)uint64", method "approveInvoice(uint64)void", method "investInInvoice(pay,uint64)void", method "payInvoice(pay,uint64)void", method "claimPayout(uint64)void", method "getInvoiceInfo(uint64)(address,address,uint64,uint64,uint64)", method "getInvestment(uint64,address)uint64"
    txna ApplicationArgs 0
    match main_createInvoice_route@5 main_approveInvoice_route@6 main_investInInvoice_route@7 main_payInvoice_route@8 main_claimPayout_route@9 main_getInvoiceInfo_route@10 main_getInvestment_route@11

main_after_if_else@18:
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    intc_1 // 0
    return

main_getInvestment_route@11:
    // smart_contracts/tradeflow/contract.algo.ts:191
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/tradeflow/contract.algo.ts:191
    // @abimethod({ readonly: true })
    callsub getInvestment
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getInvoiceInfo_route@10:
    // smart_contracts/tradeflow/contract.algo.ts:171
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/tradeflow/contract.algo.ts:171
    // @abimethod({ readonly: true })
    callsub getInvoiceInfo
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_claimPayout_route@9:
    // smart_contracts/tradeflow/contract.algo.ts:142
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/tradeflow/contract.algo.ts:142
    // @abimethod()
    callsub claimPayout
    intc_0 // 1
    return

main_payInvoice_route@8:
    // smart_contracts/tradeflow/contract.algo.ts:122
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/tradeflow/contract.algo.ts:122
    // @abimethod()
    callsub payInvoice
    intc_0 // 1
    return

main_investInInvoice_route@7:
    // smart_contracts/tradeflow/contract.algo.ts:83
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/tradeflow/contract.algo.ts:83
    // @abimethod()
    callsub investInInvoice
    intc_0 // 1
    return

main_approveInvoice_route@6:
    // smart_contracts/tradeflow/contract.algo.ts:67
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/tradeflow/contract.algo.ts:67
    // @abimethod()
    callsub approveInvoice
    intc_0 // 1
    return

main_createInvoice_route@5:
    // smart_contracts/tradeflow/contract.algo.ts:46
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/tradeflow/contract.algo.ts:46
    // @abimethod()
    callsub createInvoice
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@14:
    // smart_contracts/tradeflow/contract.algo.ts:22
    // export class Tradeflow extends Contract {
    txn OnCompletion
    bnz main_after_if_else@18
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.createInvoice(buyer: bytes, totalAmount: bytes, minInvestment: bytes, dueDate: bytes) -> bytes:
createInvoice:
    // smart_contracts/tradeflow/contract.algo.ts:46-47
    // @abimethod()
    // createInvoice(buyer: Address, totalAmount: UintN64, minInvestment: UintN64, dueDate: UintN64): UintN64 {
    proto 4 1
    // smart_contracts/tradeflow/contract.algo.ts:24
    // nextInvoiceId = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_1 // 0
    bytec_3 // "nextInvoiceId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/tradeflow/contract.algo.ts:49
    // this.nextInvoiceId.value = invoiceId + 1
    dup
    intc_0 // 1
    +
    // smart_contracts/tradeflow/contract.algo.ts:24
    // nextInvoiceId = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_3 // "nextInvoiceId"
    // smart_contracts/tradeflow/contract.algo.ts:49
    // this.nextInvoiceId.value = invoiceId + 1
    swap
    app_global_put
    // smart_contracts/tradeflow/contract.algo.ts:52
    // this.invoiceSellers(invoiceId).value = Txn.sender
    itob
    // smart_contracts/tradeflow/contract.algo.ts:27
    // invoiceSellers = BoxMap<uint64, Account>({ keyPrefix: 'is' })
    bytec 5 // "is"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:52
    // this.invoiceSellers(invoiceId).value = Txn.sender
    txn Sender
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:28
    // invoiceBuyers = BoxMap<uint64, Account>({ keyPrefix: 'ib' })
    bytec_1 // "ib"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:53
    // this.invoiceBuyers(invoiceId).value = buyer.native
    frame_dig -4
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:29
    // invoiceTotalAmounts = BoxMap<uint64, uint64>({ keyPrefix: 'ia' })
    bytec_2 // "ia"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:54
    // this.invoiceTotalAmounts(invoiceId).value = totalAmount.native
    frame_dig -3
    btoi
    itob
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:30
    // invoiceAmountsRaised = BoxMap<uint64, uint64>({ keyPrefix: 'ir' })
    bytec 6 // "ir"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:55
    // this.invoiceAmountsRaised(invoiceId).value = Uint64(0)
    intc_1 // 0
    itob
    swap
    dig 1
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:31
    // invoiceMinInvestments = BoxMap<uint64, uint64>({ keyPrefix: 'im' })
    bytec 8 // "im"
    dig 2
    concat
    // smart_contracts/tradeflow/contract.algo.ts:56
    // this.invoiceMinInvestments(invoiceId).value = minInvestment.native
    frame_dig -2
    btoi
    itob
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:32
    // invoiceDueDates = BoxMap<uint64, uint64>({ keyPrefix: 'id' })
    pushbytes "id"
    dig 2
    concat
    // smart_contracts/tradeflow/contract.algo.ts:57
    // this.invoiceDueDates(invoiceId).value = dueDate.native
    frame_dig -1
    btoi
    itob
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:33
    // invoiceStatuses = BoxMap<uint64, uint64>({ keyPrefix: 'st' })
    bytec_0 // "st"
    dig 2
    concat
    // smart_contracts/tradeflow/contract.algo.ts:58
    // this.invoiceStatuses(invoiceId).value = INVOICE_PENDING
    swap
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:60
    // return new UintN64(invoiceId)
    retsub


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.approveInvoice(invoiceId: bytes) -> void:
approveInvoice:
    // smart_contracts/tradeflow/contract.algo.ts:67-68
    // @abimethod()
    // approveInvoice(invoiceId: UintN64): void {
    proto 1 0
    // smart_contracts/tradeflow/contract.algo.ts:69
    // const id = invoiceId.native
    frame_dig -1
    btoi
    // smart_contracts/tradeflow/contract.algo.ts:70
    // assert(this.invoiceBuyers(id).exists, 'Invoice does not exist')
    itob
    // smart_contracts/tradeflow/contract.algo.ts:28
    // invoiceBuyers = BoxMap<uint64, Account>({ keyPrefix: 'ib' })
    bytec_1 // "ib"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:70
    // assert(this.invoiceBuyers(id).exists, 'Invoice does not exist')
    dup
    box_len
    bury 1
    assert // Invoice does not exist
    // smart_contracts/tradeflow/contract.algo.ts:71
    // assert(Txn.sender === this.invoiceBuyers(id).value, 'Only buyer can approve')
    txn Sender
    swap
    box_get
    assert // Box must have value
    ==
    assert // Only buyer can approve
    // smart_contracts/tradeflow/contract.algo.ts:33
    // invoiceStatuses = BoxMap<uint64, uint64>({ keyPrefix: 'st' })
    bytec_0 // "st"
    swap
    concat
    // smart_contracts/tradeflow/contract.algo.ts:72
    // assert(this.invoiceStatuses(id).value === INVOICE_PENDING, 'Invoice must be pending')
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    !
    assert // Invoice must be pending
    // smart_contracts/tradeflow/contract.algo.ts:18
    // const INVOICE_ACTIVE = Uint64(1)
    intc_0 // 1
    // smart_contracts/tradeflow/contract.algo.ts:74
    // this.invoiceStatuses(id).value = INVOICE_ACTIVE
    itob
    box_put
    retsub


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.investInInvoice(payment: uint64, invoiceId: bytes) -> void:
investInInvoice:
    // smart_contracts/tradeflow/contract.algo.ts:83-84
    // @abimethod()
    // investInInvoice(payment: gtxn.PaymentTxn, invoiceId: UintN64): void {
    proto 2 0
    // smart_contracts/tradeflow/contract.algo.ts:85
    // const id = invoiceId.native
    frame_dig -1
    btoi
    // smart_contracts/tradeflow/contract.algo.ts:86
    // assert(this.invoiceSellers(id).exists, 'Invoice does not exist')
    itob
    // smart_contracts/tradeflow/contract.algo.ts:27
    // invoiceSellers = BoxMap<uint64, Account>({ keyPrefix: 'is' })
    bytec 5 // "is"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:86
    // assert(this.invoiceSellers(id).exists, 'Invoice does not exist')
    dup
    box_len
    bury 1
    assert // Invoice does not exist
    // smart_contracts/tradeflow/contract.algo.ts:33
    // invoiceStatuses = BoxMap<uint64, uint64>({ keyPrefix: 'st' })
    bytec_0 // "st"
    dig 2
    concat
    dup
    cover 3
    // smart_contracts/tradeflow/contract.algo.ts:87
    // assert(this.invoiceStatuses(id).value === INVOICE_ACTIVE, 'Invoice must be active')
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:18
    // const INVOICE_ACTIVE = Uint64(1)
    intc_0 // 1
    // smart_contracts/tradeflow/contract.algo.ts:87
    // assert(this.invoiceStatuses(id).value === INVOICE_ACTIVE, 'Invoice must be active')
    ==
    assert // Invoice must be active
    // smart_contracts/tradeflow/contract.algo.ts:29
    // invoiceTotalAmounts = BoxMap<uint64, uint64>({ keyPrefix: 'ia' })
    bytec_2 // "ia"
    dig 2
    concat
    // smart_contracts/tradeflow/contract.algo.ts:89
    // const totalAmount = this.invoiceTotalAmounts(id).value
    box_get
    swap
    btoi
    dup
    cover 3
    cover 4
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:30
    // invoiceAmountsRaised = BoxMap<uint64, uint64>({ keyPrefix: 'ir' })
    bytec 6 // "ir"
    dig 3
    concat
    dup
    cover 4
    // smart_contracts/tradeflow/contract.algo.ts:90
    // const amountRaised = this.invoiceAmountsRaised(id).value
    box_get
    swap
    btoi
    dup
    cover 3
    cover 5
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:31
    // invoiceMinInvestments = BoxMap<uint64, uint64>({ keyPrefix: 'im' })
    bytec 8 // "im"
    dig 4
    concat
    // smart_contracts/tradeflow/contract.algo.ts:91
    // const minInvestment = this.invoiceMinInvestments(id).value
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:92
    // const seller = this.invoiceSellers(id).value
    swap
    box_get
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:95
    // assert(payment.receiver === seller, 'Payment must go to seller')
    frame_dig -2
    gtxns Receiver
    ==
    assert // Payment must go to seller
    // smart_contracts/tradeflow/contract.algo.ts:96
    // assert(payment.amount >= minInvestment, 'Below minimum investment')
    frame_dig -2
    gtxns Amount
    dup
    cover 5
    dup
    uncover 2
    >=
    assert // Below minimum investment
    // smart_contracts/tradeflow/contract.algo.ts:97
    // assert(payment.amount <= totalAmount - amountRaised, 'Exceeds funding need')
    cover 2
    -
    <=
    assert // Exceeds funding need
    // smart_contracts/tradeflow/contract.algo.ts:100
    // const investmentKey = op.concat(op.itob(id), payment.sender.bytes)
    frame_dig -2
    gtxns Sender
    concat
    // smart_contracts/tradeflow/contract.algo.ts:36
    // investments = BoxMap<bytes, uint64>({ keyPrefix: 'inv' })
    bytec 7 // "inv"
    swap
    concat
    dup
    // smart_contracts/tradeflow/contract.algo.ts:101
    // const currentInvestment: uint64 = this.investments(investmentKey).exists
    box_len
    bury 1
    // smart_contracts/tradeflow/contract.algo.ts:101-103
    // const currentInvestment: uint64 = this.investments(investmentKey).exists
    //   ? this.investments(investmentKey).value
    //   : Uint64(0)
    bz investInInvoice_ternary_false@2
    // smart_contracts/tradeflow/contract.algo.ts:102
    // ? this.investments(investmentKey).value
    frame_dig 5
    box_get
    swap
    btoi
    swap
    assert // Box must have value

investInInvoice_ternary_merge@3:
    // smart_contracts/tradeflow/contract.algo.ts:104
    // this.investments(investmentKey).value = currentInvestment + payment.amount
    frame_dig 4
    dup
    cover 2
    +
    itob
    frame_dig 5
    swap
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:107
    // const newAmountRaised: uint64 = amountRaised + payment.amount
    frame_dig 3
    +
    // smart_contracts/tradeflow/contract.algo.ts:108
    // this.invoiceAmountsRaised(id).value = newAmountRaised
    dup
    itob
    frame_dig 2
    swap
    box_put
    // smart_contracts/tradeflow/contract.algo.ts:111
    // if (newAmountRaised >= totalAmount) {
    frame_dig 1
    >=
    bz investInInvoice_after_if_else@5
    // smart_contracts/tradeflow/contract.algo.ts:19
    // const INVOICE_FUNDED = Uint64(2)
    intc_2 // 2
    // smart_contracts/tradeflow/contract.algo.ts:112
    // this.invoiceStatuses(id).value = INVOICE_FUNDED
    itob
    frame_dig 0
    swap
    box_put

investInInvoice_after_if_else@5:
    retsub

investInInvoice_ternary_false@2:
    // smart_contracts/tradeflow/contract.algo.ts:103
    // : Uint64(0)
    intc_1 // 0
    b investInInvoice_ternary_merge@3


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.payInvoice(payment: uint64, invoiceId: bytes) -> void:
payInvoice:
    // smart_contracts/tradeflow/contract.algo.ts:122-123
    // @abimethod()
    // payInvoice(payment: gtxn.PaymentTxn, invoiceId: UintN64): void {
    proto 2 0
    // smart_contracts/tradeflow/contract.algo.ts:124
    // const id = invoiceId.native
    frame_dig -1
    btoi
    // smart_contracts/tradeflow/contract.algo.ts:125
    // assert(this.invoiceBuyers(id).exists, 'Invoice does not exist')
    itob
    // smart_contracts/tradeflow/contract.algo.ts:28
    // invoiceBuyers = BoxMap<uint64, Account>({ keyPrefix: 'ib' })
    bytec_1 // "ib"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:125
    // assert(this.invoiceBuyers(id).exists, 'Invoice does not exist')
    dup
    box_len
    bury 1
    assert // Invoice does not exist
    // smart_contracts/tradeflow/contract.algo.ts:126
    // assert(Txn.sender === this.invoiceBuyers(id).value, 'Only buyer can pay invoice')
    txn Sender
    swap
    box_get
    assert // Box must have value
    ==
    assert // Only buyer can pay invoice
    // smart_contracts/tradeflow/contract.algo.ts:33
    // invoiceStatuses = BoxMap<uint64, uint64>({ keyPrefix: 'st' })
    bytec_0 // "st"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:127
    // assert(this.invoiceStatuses(id).value === INVOICE_FUNDED, 'Invoice must be funded')
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:19
    // const INVOICE_FUNDED = Uint64(2)
    intc_2 // 2
    // smart_contracts/tradeflow/contract.algo.ts:127
    // assert(this.invoiceStatuses(id).value === INVOICE_FUNDED, 'Invoice must be funded')
    ==
    assert // Invoice must be funded
    // smart_contracts/tradeflow/contract.algo.ts:130
    // assert(payment.receiver === Global.currentApplicationAddress, 'Payment must go to contract')
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must go to contract
    // smart_contracts/tradeflow/contract.algo.ts:131
    // assert(payment.amount === this.invoiceTotalAmounts(id).value, 'Wrong payment amount')
    frame_dig -2
    gtxns Amount
    // smart_contracts/tradeflow/contract.algo.ts:29
    // invoiceTotalAmounts = BoxMap<uint64, uint64>({ keyPrefix: 'ia' })
    bytec_2 // "ia"
    uncover 3
    concat
    // smart_contracts/tradeflow/contract.algo.ts:131
    // assert(payment.amount === this.invoiceTotalAmounts(id).value, 'Wrong payment amount')
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    ==
    assert // Wrong payment amount
    // smart_contracts/tradeflow/contract.algo.ts:20
    // const INVOICE_PAID = Uint64(3)
    intc_3 // 3
    // smart_contracts/tradeflow/contract.algo.ts:134
    // this.invoiceStatuses(id).value = INVOICE_PAID
    itob
    box_put
    retsub


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.claimPayout(invoiceId: bytes) -> void:
claimPayout:
    // smart_contracts/tradeflow/contract.algo.ts:142-143
    // @abimethod()
    // claimPayout(invoiceId: UintN64): void {
    proto 1 0
    // smart_contracts/tradeflow/contract.algo.ts:144
    // const id = invoiceId.native
    frame_dig -1
    btoi
    // smart_contracts/tradeflow/contract.algo.ts:145
    // assert(this.invoiceStatuses(id).value === INVOICE_PAID, 'Invoice not paid yet')
    itob
    // smart_contracts/tradeflow/contract.algo.ts:33
    // invoiceStatuses = BoxMap<uint64, uint64>({ keyPrefix: 'st' })
    bytec_0 // "st"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:145
    // assert(this.invoiceStatuses(id).value === INVOICE_PAID, 'Invoice not paid yet')
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:20
    // const INVOICE_PAID = Uint64(3)
    intc_3 // 3
    // smart_contracts/tradeflow/contract.algo.ts:145
    // assert(this.invoiceStatuses(id).value === INVOICE_PAID, 'Invoice not paid yet')
    ==
    assert // Invoice not paid yet
    // smart_contracts/tradeflow/contract.algo.ts:148
    // const investmentKey = op.concat(op.itob(id), Txn.sender.bytes)
    txn Sender
    concat
    // smart_contracts/tradeflow/contract.algo.ts:36
    // investments = BoxMap<bytes, uint64>({ keyPrefix: 'inv' })
    bytec 7 // "inv"
    swap
    concat
    // smart_contracts/tradeflow/contract.algo.ts:149
    // assert(this.investments(investmentKey).exists, 'No investment found')
    dup
    box_len
    bury 1
    assert // No investment found
    // smart_contracts/tradeflow/contract.algo.ts:150
    // const invested = this.investments(investmentKey).value
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:151
    // assert(invested > Uint64(0), 'Already claimed or no investment')
    dup
    assert // Already claimed or no investment
    // smart_contracts/tradeflow/contract.algo.ts:154-160
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: invested,
    //     fee: Uint64(0), // Caller pays fees
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/tradeflow/contract.algo.ts:156
    // receiver: Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/tradeflow/contract.algo.ts:154-159
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: invested,
    //     fee: Uint64(0), // Caller pays fees
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/tradeflow/contract.algo.ts:158
    // fee: Uint64(0), // Caller pays fees
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/tradeflow/contract.algo.ts:154-160
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: invested,
    //     fee: Uint64(0), // Caller pays fees
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/tradeflow/contract.algo.ts:163
    // this.investments(investmentKey).value = Uint64(0)
    intc_1 // 0
    itob
    box_put
    retsub


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.getInvoiceInfo(invoiceId: bytes) -> bytes, bytes, bytes, bytes, bytes:
getInvoiceInfo:
    // smart_contracts/tradeflow/contract.algo.ts:171-172
    // @abimethod({ readonly: true })
    // getInvoiceInfo(invoiceId: UintN64): [Address, Address, UintN64, UintN64, UintN64] {
    proto 1 5
    // smart_contracts/tradeflow/contract.algo.ts:173
    // const id = invoiceId.native
    frame_dig -1
    btoi
    // smart_contracts/tradeflow/contract.algo.ts:174
    // assert(this.invoiceSellers(id).exists, 'Invoice does not exist')
    itob
    // smart_contracts/tradeflow/contract.algo.ts:27
    // invoiceSellers = BoxMap<uint64, Account>({ keyPrefix: 'is' })
    bytec 5 // "is"
    dig 1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:174
    // assert(this.invoiceSellers(id).exists, 'Invoice does not exist')
    dup
    box_len
    bury 1
    assert // Invoice does not exist
    // smart_contracts/tradeflow/contract.algo.ts:177
    // new Address(this.invoiceSellers(id).value),
    box_get
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:28
    // invoiceBuyers = BoxMap<uint64, Account>({ keyPrefix: 'ib' })
    bytec_1 // "ib"
    dig 2
    concat
    // smart_contracts/tradeflow/contract.algo.ts:178
    // new Address(this.invoiceBuyers(id).value),
    box_get
    assert // Box must have value
    // smart_contracts/tradeflow/contract.algo.ts:29
    // invoiceTotalAmounts = BoxMap<uint64, uint64>({ keyPrefix: 'ia' })
    bytec_2 // "ia"
    dig 3
    concat
    // smart_contracts/tradeflow/contract.algo.ts:179
    // new UintN64(this.invoiceTotalAmounts(id).value),
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    itob
    // smart_contracts/tradeflow/contract.algo.ts:30
    // invoiceAmountsRaised = BoxMap<uint64, uint64>({ keyPrefix: 'ir' })
    bytec 6 // "ir"
    dig 4
    concat
    // smart_contracts/tradeflow/contract.algo.ts:180
    // new UintN64(this.invoiceAmountsRaised(id).value),
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    itob
    // smart_contracts/tradeflow/contract.algo.ts:33
    // invoiceStatuses = BoxMap<uint64, uint64>({ keyPrefix: 'st' })
    bytec_0 // "st"
    uncover 5
    concat
    // smart_contracts/tradeflow/contract.algo.ts:181
    // new UintN64(this.invoiceStatuses(id).value),
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    itob
    // smart_contracts/tradeflow/contract.algo.ts:176-182
    // return [
    //   new Address(this.invoiceSellers(id).value),
    //   new Address(this.invoiceBuyers(id).value),
    //   new UintN64(this.invoiceTotalAmounts(id).value),
    //   new UintN64(this.invoiceAmountsRaised(id).value),
    //   new UintN64(this.invoiceStatuses(id).value),
    // ]
    retsub


// smart_contracts/tradeflow/contract.algo.ts::Tradeflow.getInvestment(invoiceId: bytes, investor: bytes) -> bytes:
getInvestment:
    // smart_contracts/tradeflow/contract.algo.ts:191-192
    // @abimethod({ readonly: true })
    // getInvestment(invoiceId: UintN64, investor: Address): UintN64 {
    proto 2 1
    // smart_contracts/tradeflow/contract.algo.ts:193
    // const id = invoiceId.native
    frame_dig -2
    btoi
    // smart_contracts/tradeflow/contract.algo.ts:194
    // const investmentKey = op.concat(op.itob(id), investor.native.bytes)
    itob
    frame_dig -1
    concat
    // smart_contracts/tradeflow/contract.algo.ts:36
    // investments = BoxMap<bytes, uint64>({ keyPrefix: 'inv' })
    bytec 7 // "inv"
    swap
    concat
    dup
    // smart_contracts/tradeflow/contract.algo.ts:195
    // const amount = this.investments(investmentKey).exists ? this.investments(investmentKey).value : Uint64(0)
    box_len
    bury 1
    bz getInvestment_ternary_false@2
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value

getInvestment_ternary_merge@3:
    // smart_contracts/tradeflow/contract.algo.ts:196
    // return new UintN64(amount)
    itob
    swap
    retsub

getInvestment_ternary_false@2:
    // smart_contracts/tradeflow/contract.algo.ts:195
    // const amount = this.investments(investmentKey).exists ? this.investments(investmentKey).value : Uint64(0)
    intc_1 // 0
    b getInvestment_ternary_merge@3
